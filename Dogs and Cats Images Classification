import zipfile
import tensorflow as tf
from tensorflow import keras
from keras import Sequential
from keras.layers import Dense, Conv2D, MaxPooling2D, Flatten, BatchNormalization, Dropout
import matplotlib.pyplot as plt
import cv2
zip_ref = zipfile.ZipFile('/content/dogs and cats.zip', 'r')
zip_ref.extractall('/content')
zip_ref.close()
train_ds = keras.utils.image_dataset_from_directory(directory = '/content/train',
        labels = 'inferred', label_mode = 'int', batch_size = 32, image_size = (256,256))
validation_ds = keras.utils.image_dataset_from_directory(directory = '/content/test',
        labels = 'inferred', label_mode = 'int', batch_size = 32, image_size = (256,256))
def process(image, label):
    image = tf.cast(image/255, tf.float32)
    return image, label
train_ds = train_ds.map(process)
validation_ds = validation_ds.map(process)
model1 = Sequential()
model1.add(Conv2D(32, kernel_size = (3,3), padding = 'valid', activation = 'relu',
                 input_shape = (256,256,3)))
model1.add(MaxPooling2D(pool_size = (2,2), strides = 2, padding = 'valid'))
model1.add(Conv2D(64, kernel_size = (3,3), padding = 'valid', activation = 'relu'))
model1.add(MaxPooling2D(poolsize = (2,2), strides = 2, padding = 'valid'))
model1.add(Conv2D(128, kernel_size = (3,3), padding = 'valid', activation = 'relu',))
model1.add(MaxPooling2D(poo_size = (2,2), strides = 2, padding = 'valid'))
model1.add(Flatten())
model1.add(Dense(128, activation = 'relu'))
model1.add(Dense(64, activation = 'relu'))
model1.add(Dense(1, activation = 'sigmoid'))
model1.summary()
model1.compile(optimizer = 'adam', loss = 'binary_crossentropy', metrics = ['accuracy'])
history = model1.fit(train_ds, epochs = 10, validation_data = validation_ds)
print(history)
plt.plot(history.history['accuracy'], color = 'green', label = 'train')
plt.plot(history.history['val_accuracy'], color = 'red', label = 'validation')
plt.legend()
plt.show()
plt.plot(history.history['loss'], color = 'green', label = 'train')
plt.plot(history.history['val_loss'], color = 'red', label = 'validation')
plt.legend()
plt.show()
# This model gives good results on the training data but fails to give good results for testing data
# This is due to overfitting
model2 = Sequential()
model2.add(Conv2D(32, kernel_size = (3,3), padding = 'valid', activation = 'relu',
                 input_shape = (256,256,3)))
model2.add(BatchNormalization())
model2.add(MaxPooling2D(pool_size = (2,2), strides = 2, activation = 'relu'))
model2.add(Conv2D(64, kernel_size = (3,3), padding = 'valid', activation = 'relu',))
model2.add(BatchNormalization())
model2.add(MaxPooling2D(pool_size = (2,2), strides = 2, activation = 'relu'))
model2.add(Conv2D(128, kernel_size = (3,3), padding = 'valid', activation = 'relu'))
model2.add(BatchNormalization())
model2.add(MaxPooling2D(pool_size = (2,2), strides = 2, activation = 'relu'))
model2.add(Flatten())
model2.add(Dense(128, activation = 'relu'))
model2.add(Dropout())
model2.add(Dense(64, activation = 'relu'))
model2.add(Dropout())
model2.add(Dense(1, activation = 'sigmoid'))
model2.summary()
model2.compile(optimizer = 'adam', loss = 'binary_crossentropy', metrics = ['accuracy'])
history = model2.fit(train_ds, epochs = 10, validation_data = validation_ds)
plt.plot(history.history['accuracy'], color = 'blue', label = 'train')
plt.plot(history.history['val_accuracy'], color = 'orange', label = 'validation')
plt.legend()
plt.show()
plt.plot(history.history['loss'], color = 'blue', label = 'train')
plt.plot(history.history['val_loss'], color = 'orange', label = 'validation')
plt.legend()
plt.show()
# This model reduces overfitting by using Batch normalization and dropout methods
# This also improves the accuracy to some extent
test_img = cv2.imread('content/dog.jpg')
plt.imshow(test_img)
print(test_img.shape)
test_img = cv2.resize(test_img,(256,256))
test_input = test_img.reshape(1,256,256,3)
model2.predict(test_img)
test_img = cv2.imread('content/cat.jpg')
plt.imshow(test_img)
print(test_img.shape)
test_img = cv2.resize(test_img,(256,256))
test_input = test_img.reshape(1,256,256,3)
model2.predict(test_img)
